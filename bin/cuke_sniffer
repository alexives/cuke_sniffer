#!/usr/bin/env ruby
$:.unshift(File.dirname(__FILE__) + '/../lib') unless $:.include?(File.dirname(__FILE__) + '/../lib')

require 'cuke_sniffer'

help_cmd_txt = "Welcome to CukeSniffer!
Calling CukeSniffer with no arguments will run it against the current directory.
Other Options for Running include:
  -o, --out <type> (name)                   : Where <type> is 'html', 'min_html', 'junit_xml' or 'xml'.
                                              Runs CukeSniffer then outputs an
                                              html/xml file in the current
                                              directory (with optional name, default: #{CukeSniffer::Constants::DEFAULT_OUTPUT_FILE_NAME}).
  -h,  --help                               : You get this lovely document.
  -c,  --config <config_file>               : A specified yaml config file (Defaults to #{CukeSniffer::Constants::DEFAULT_CONFIG_FILE_NAME})
  -p,  --project <project_root>             : Root directory of project.
  -f,  --features <feature_path>            : Path to features directory.
  -s,  --step_definitions <step_def_path>   : Path to step definitions directory.
  -hk, --hooks <hooks_path>                 : Path to support directory.
  -nc, --no_catalog                         : Disable cataloging of steps. Reduced runtime and no
  -ud, --use-default-rules                  : Disable rule overrides present in the config file.
"

def find_index_by_regex_match(list, regex)
  list.each do |item|
    return list.index(item) if item =~ regex
  end
  nil
end

def build_cli_hash(argv)
  cucumber_hash ={
      :hooks_location => /-hk|--hooks/,
      :features_location => /-f|--features/,
      :step_definitions_location => /-s|--step_definitions/,
      :project_location => /-p|--project/,
      :config_file => /-c|--config/,
      :file_format => /-o|--out/}

  cli_hash = {}
  cucumber_hash.each do |symbol, regex|
    index_of_key = find_index_by_regex_match(argv, regex)
    if !index_of_key.nil?
      cli_hash[symbol] = argv[index_of_key + 1]
      # Special handling for file format.
      if symbol == :file_format
        cli_hash[:file_name]  = argv[index_of_key + 2]
      end
    end
  end
  cli_hash[:no_catalog] = true if find_index_by_regex_match(argv, /-nc|--no_catalog/)
  cli_hash[:use_default_rules] = true if find_index_by_regex_match(argv, /-ud|--use-default-rules/)
  cli_hash
end

def output(file_type, file_name)
  case file_type
    when "stdout"
      puts @cuke_sniffer.output_results
    when "xml"
      file_name.nil? ? @cuke_sniffer.output_xml  : @cuke_sniffer.output_xml(file_name)
    when "html"
      file_name.nil? ? @cuke_sniffer.output_html : @cuke_sniffer.output_html(file_name)
    when "min_html"
      file_name.nil? ? @cuke_sniffer.output_min_html : @cuke_sniffer.output_min_html(file_name)
    when "junit_xml"
      file_name.nil? ? @cuke_sniffer.output_junit_xml : @cuke_sniffer.output_junit_xml(file_name)
    else
      puts "#{file_type} is not a supported version of cuke_sniffer output."
  end
end

if ARGV.include? "-h" or ARGV.include? "--help"
  puts help_cmd_txt
  exit
end

arguments_hash = build_cli_hash(ARGV)
config = CukeSniffer::Config.new(arguments_hash)
@cuke_sniffer = CukeSniffer::CLI.new(config)
output(config.output_format, config.output_file)

puts "Completed Sniffing."
